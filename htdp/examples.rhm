#lang shplait
type Tree
| Leaf(value :: Int)
| Node(left :: Tree, right :: Tree)

fun tree_sum(t :: Tree) :: Int
  ....

check:  tree_sum(Leaf(1))
        ~is: 1
check:  tree_sum(Node(Node(Leaf(1), Leaf(2)), Leaf(4)))
        ~is: 7
check:  tree_sum(Node(Node(Leaf(1), Leaf(2)), Node(Leaf(4), Leaf(5))))
        ~is: 12


fun safe_div(n :: Int, d :: Int):: Optionof(Int):
  ....

check:  safe_div(10, 2)
        ~is: some(5)
check:  safe_div(10, 0)
        ~is: none()

// Find the first element equal to n, or none if not found
fun find(lst :: Listof(Int), n :: Int) :: Optionof(Int)
  ....


check:  find([0, 1, 2], 0)
        ~is: some(0)
check:  find([0, 1, 2], 2)
        ~is: some(2)
check:  find([0, 1, 2], 3)
        ~is: none()

// Find the index of the first element equal to n, or none if not found
fun index_of(lst :: Listof(Int), n :: Int) :: Optionof(Int)
  ....

check:  index_of([0, 1, 2], 0)
        ~is: some(0)
check:  index_of([0, 1, 2], 2)
        ~is: some(2)
check:  index_of([0, 1, 2], 3)
        ~is: none()

// return the altenating values of a list [1,2,3] -> [1,3] // [1,2,3,4] -> [1,3] // [1,2,3,4,5] -> [1,3,5]
fun alternates(l :: Listof(Int)) :: Listof(Int):
  ....

check:  alternates([1, 2, 3])
        ~is: [1, 3]
check:  alternates([1, 2, 3, 4])
        ~is: [1, 3]
check:  alternates([1, 2, 3, 4, 5])
        ~is: [1, 3, 5]

// Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
// You may assume that each input would have exactly one solution, and you may not use the same element twice.
// add_two
// nums = [2,7,11,15], target = 9
// Output: [0,1]
fun add_two(two :: Listof(Int), target :: Int) :: Optionof(Listof(Int)):
  ....

check:  add_two([2, 7, 11, 15], 9)
        ~is: [0, 1]
check:  add_two([2, 7, 11, 15], 18)
        ~is: [1, 2]
check:  add_two([2, 7, 11, 15], 26)
        ~is: [2, 3]

// Find the index of the first element satisfying the predicate `p`, or none if not found
fun find_pred(l :: Listof(Int), p :: Int -> Boolean) :: Optionof(Int):
  ....


check:  find([0, 1, 2], fun(x): x == 0)
        ~is: some(0)
check:  find(["a", "b", "c"], fun(x): x == "b")
        ~is: some("b")
check:  find([0, 1, 2], 3)
        ~is: none()

// Find the index of the first element satisfying the predicate `p`, or none if not found
fun index_of_pred(l :: Listof(Int), p :: Int -> Boolean) :: Optionof(Int) 
  ....

check:  index_of([0, 1, 2], fun(x): x == 0)
        ~is: some(0)
check:  index_of([0, 1, -2], fun(x): x == -2)
        ~is: some(2)
check:  index_of(["a", "b", "c"], fun(x): x == "z")
        ~is: none()